mod default;
mod scale;
mod slider;

pub use default::*;
pub use imgui;
pub use scale::*;
pub use slider::*;

/// Options for rendering a value as a struct (i.e. draw all of its subfields)
#[derive(Debug, Default)]
pub struct InspectArgsStruct {
    pub header: Option<bool>,
    pub indent_children: Option<bool>,
}

impl From<InspectArgsDefault> for InspectArgsStruct {
    fn from(default_args: InspectArgsDefault) -> Self {
        Self {
            header: default_args.header,
            indent_children: default_args.indent_children,
        }
    }
}

/// Renders a struct (i.e. draw all of its subfields). Most traits are implemented by hand-written code, but this trait
/// is normally generated by putting `#[derive(Inspect)]` on a struct
pub trait InspectRenderStruct<T> {
    fn render(data: &[&T], label: &'static str, ui: &imgui::Ui, args: &InspectArgsStruct);
    fn render_mut(
        data: &mut [&mut T],
        label: &'static str,
        ui: &imgui::Ui,
        args: &InspectArgsStruct,
    ) -> bool;
}

/// Utility function that, given a list of references, returns Some(T) if they are the same, otherwise None
pub fn get_same_or_none<T: PartialEq + Clone>(data: &[&T]) -> Option<T> {
    if data.is_empty() {
        return None;
    }

    let first = data[0].clone();
    for d in data {
        if **d != first {
            return None;
        }
    }

    Some(first)
}

/// Utility function that, given a list of references, returns Some(T) if they are the same, otherwise None
fn get_same_or_none_mut<T: PartialEq + Clone>(data: &mut [&mut T]) -> Option<T> {
    if data.is_empty() {
        return None;
    }

    let first = data[0].clone();
    for d in data {
        if **d != first {
            return None;
        }
    }

    Some(first)
}

#[rustfmt::skip]
#[macro_export]
macro_rules! empty_inspect_impl {
    ($x : ty) => {
        impl imgui_inspect::InspectRenderDefault<$x> for $x {
            fn render(_: &[&$x], _: &'static str, ui: &imgui::Ui, _: &imgui_inspect::InspectArgsDefault) {
                ui.text(std::stringify!($x))
            }

            fn render_mut(_: &mut [&mut $x], _: &'static str, ui: &imgui::Ui, _: &imgui_inspect::InspectArgsDefault) -> bool {
                ui.text(std::stringify!($x));
                false
            }
        }
    };
}

#[rustfmt::skip]
#[macro_export]
macro_rules! debug_inspect_impl {
    ($t: ty) => {
        impl imgui_inspect::InspectRenderDefault<$t> for $t {
            fn render(
                data: &[&$t],
                label: &'static str,
                ui: &imgui::Ui,
                _: &imgui_inspect::InspectArgsDefault,
            ) {
                if data.len() != 1 {
                    unimplemented!()
                }
                let d = &data[0];
                ui.text(imgui::im_str!("{:?} {}", d, label));
            }

            fn render_mut(
                data: &mut [&mut $t],
                label: &'static str,
                ui: &imgui::Ui,
                _: &imgui_inspect::InspectArgsDefault,
            ) -> bool {
                if data.len() != 1 {
                    unimplemented!()
                }
                let d = &data[0];
                ui.text(imgui::im_str!("{:?} {}", d, label));
                false
            }
        }
    };
}

#[rustfmt::skip]
#[macro_export]
macro_rules! enum_inspect_impl {
    ($t: ty; $($x: pat),+) => {
        impl imgui_inspect::InspectRenderDefault<$t> for $t {
            fn render(data: &[&$t], label: &'static str, ui: &imgui::Ui, _: &imgui_inspect::InspectArgsDefault,
            ) {
                if data.len() != 1 {
                    unimplemented!()
                }
                let d = &data[0];
                let mut aha = "No match";
                $(
                    if let $x = d {
                        aha = stringify!($x);
                    }
                )+

                ui.text(imgui::im_str!("{} {}", &aha, label));
            }

            fn render_mut(
                data: &mut [&mut $t],
                label: &'static str,
                ui: &imgui::Ui,
                _: &imgui_inspect::InspectArgsDefault,
            ) -> bool {
                if data.len() != 1 {
                    unimplemented!()
                }
                let d = &mut data[0];
                let mut aha = "No match";
                $(
                    if let $x = d {
                        aha = stringify!($x);
                    }
                )+

                ui.text(imgui::im_str!("{} {}", &aha, label));
                false
            }
        }
    };
}
